package echology.proxy;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.SocketChannel;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Represent a proxy client. It has an associated channel, an incoming data
 * buffer and provides methods to obtain any incoming client commands
 *
 * @author smarios@jaist.ac.jp
 */
public class Client {

    /**
     * Associated channel token
     */
    private final SelectionKey client_key;
    /**
     * raw incoming data buffer
     */
    private final ByteBuffer buffer;
    /**
     * list of commands generated so far
     */
    private List<ClientCommand> command_buffer;

    public Client(SelectionKey key) {
        this.client_key = key;
        command_buffer = new ArrayList<>();
        buffer = ByteBuffer.allocate(512);
    }

    public int receiveData() {
        try {
            int bytes_read = ((SocketChannel) client_key.channel()).read(buffer);
            if (bytes_read > 0) {
                generateCommands();
            }
            return bytes_read;
        } catch (IOException ex) {
            Logger.getLogger(Client.class.getName()).log(Level.SEVERE, null, ex);
            return -1;
        }
    }

    private void generateCommands() {
        String contents = new String(this.buffer.array());
        System.out.println("raw command string: " + contents);

        StringTokenizer split_commands = new StringTokenizer(contents, "\n");
        while (split_commands.hasMoreTokens()) {
            String command = split_commands.nextToken();
            //we have a new line in the buffer so we should have a complete
            //command. Try to generate a command from it.    
            try {
                ClientCommand client_command = new ClientCommand(command.trim());
                client_command.setClient_key(client_key);
                command_buffer.add(client_command);
            } catch (InvalidTargetException ex) {
                if (ex.getMessage() != null) {
                    Logger.getLogger(Client.class.getName()).log(Level.WARNING, "Check the command generated by your client", ex.getMessage());
                }
                //"reset" the buffer?!
                this.buffer.position(0);
            }
        }

        //we need to advance the buffer to where the last index of new line is
        //with compact, we keep any incomplete command contents.
        int last_index = contents.lastIndexOf('\n');
        int last_index_r = contents.lastIndexOf('\r');
        if (last_index_r > last_index) {
            last_index = last_index_r;
        }

        if (last_index > 0) {
            this.buffer.position(last_index);
            this.buffer.compact();
            this.buffer.position(0);
        }
    }

    List<ClientCommand> getCommands() {
        List<ClientCommand> commands = command_buffer;
        command_buffer = new ArrayList<>();
        return commands;
    }
}
